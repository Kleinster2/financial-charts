<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Charting Sandbox (Lightweight Charts vLatest)</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:1rem;background:#fafafa;}
    #controls{margin-bottom:1rem;}
    #chart{width:100%;height:600px;border:1px solid #ccc;background:#fff;}
    input[type=text]{width:300px;padding:4px;font-size:1rem;}
    button{padding:4px 10px;margin-left:6px;font-size:1rem;}
    .chip{display:inline-block;background:#e0e0e0;border-radius:4px;padding:2px 6px;margin:2px;font-size:0.9rem;}
    .chip .close{margin-left:4px;cursor:pointer;font-weight:bold;}
  </style>
  <!-- Latest Lightweight Charts build -->
  <script src="https://unpkg.com/lightweight-charts@5.0.8/dist/lightweight-charts.standalone.development.js"></script>
</head>
<body>
  <h2>Lightweight Charts Sandbox</h2>
  <div id="controls">
    <label>
      Tickers (comma-separated):
      <input id="tickers-input" type="text" value="SPY">
    </label>
    <button id="plot-btn">Plot</button>
    <button id="toggle-diff-btn">Hide Diff Pane</button>
    <div id="ticker-chips"></div>
  </div>
  <div id="chart"></div>

  <script>
    const chartContainer = document.getElementById('chart');
    // --- Chart Setup ---
    const chart = LightweightCharts.createChart(chartContainer, {
      layout: { background: { type: 'solid', color: '#ffffff' }, textColor: '#333' },
      grid: { vertLines: { color: '#eee' }, horzLines: { color: '#eee' } },
      timeScale: { secondsVisible: false, rightOffset: 10, fixLeftEdge: true },
      rightPriceScale: { visible: true, scaleMargins: { top: 0.1, bottom: 0.1 } },
      // Create a second price scale for the bottom pane
      leftPriceScale: { visible: true, scaleMargins: { top: 0.1, bottom: 0.1 } }, 
    });

    // Pane management
    let bottomPane = chart.addPane({ height: 120 });
    let bottomPaneIndex = bottomPane.paneIndex ? bottomPane.paneIndex() : 1; // fallback 1
    let showDiff = true;

    const priceSeriesMap = new Map();
    const diffSeriesMap = new Map();
    // PriceLine handles to keep single 0% reference lines per pane
    let zeroLineTop = null;
    let zeroLineBottom = null;
    // Store original (rebased-to-100-at-start) data for each ticker to enable dynamic rebasing
    const originalNormalizedData = {};

    // Color palette for multiple tickers
    const colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0', '#546E7A', '#26a69a', '#D10CE8'];
    let colorIndex = 0;

    const STORAGE_KEY = 'sandbox_tickers';

    // Restore saved tickers on load
    const storedTickers = localStorage.getItem(STORAGE_KEY);
    if (storedTickers) {
      document.getElementById('tickers-input').value = storedTickers;
      // plot will run later after event listeners are wired
      setTimeout(() => plot(), 0);
    }

    function renderChips(tickers){
      const container=document.getElementById('ticker-chips');
      if(!container) return;
      container.innerHTML='';
      tickers.forEach((t, idx)=>{
        const chip=document.createElement('span');
        chip.className='chip';
        const color=colors[idx % colors.length];
        chip.style.backgroundColor=color;
        chip.style.color='#fff';
        chip.textContent=t;
        const close=document.createElement('span');
        close.className='close';
        close.textContent='Ã—';
        close.addEventListener('click',()=>{
          const current=document.getElementById('tickers-input').value.split(/[\s,]+/).filter(Boolean).map(x=>x.toUpperCase());
          const updated=current.filter(x=>x!==t);
          document.getElementById('tickers-input').value=updated.join(', ');
          plot();
        });
        chip.appendChild(close);
        container.appendChild(chip);
      });
    }

    // --- Plotting Logic ---
    async function plot() {
      // 1. Clear existing series
      for (const series of priceSeriesMap.values()) chart.removeSeries(series);
      for (const series of diffSeriesMap.values()) chart.removeSeries(series);
      // Reset zero line handles (they are auto-removed with their series)
      zeroLineTop = null;
      zeroLineBottom = null;

      priceSeriesMap.clear();
      // Ensure pane exists or removed based on showDiff flag
      if (showDiff && !bottomPane) {
        bottomPane = chart.addPane({ height: 120 });
        bottomPaneIndex = bottomPane.paneIndex ? bottomPane.paneIndex() : 1;
      }
      if (!showDiff && bottomPane) {
        chart.removePane(bottomPane);
        bottomPane = null;
        bottomPaneIndex = null;
      }
      diffSeriesMap.clear();
      colorIndex = 0;

      // 2. Fetch Data & persist selections
      const tickersRaw = document.getElementById('tickers-input').value.trim();
      if (tickersRaw) {
        localStorage.setItem(STORAGE_KEY, tickersRaw);
      } else {
        localStorage.removeItem(STORAGE_KEY);
      }
      if (!tickersRaw) return;
      const tickers = tickersRaw.split(/[\s,]+/).filter(Boolean).map(t => t.toUpperCase());
      renderChips(tickers);
      const resp = await fetch(`http://localhost:5000/api/data?tickers=${tickers.join(',')}`);
      if (!resp.ok) { alert('API error'); return; }
      const rawData = await resp.json();
      console.log('raw keys', Object.keys(rawData));

      // 3. Normalize Data (Rebase to 100)
      const rebasedData = {};
      for (const ticker of tickers) {
        let tickerData = rawData[ticker]?.filter(p => p.value != null) || [];
        // Ensure data is sorted by time ascending (Lightweight Charts requirement)
        tickerData = tickerData.sort((a, b) => a.time - b.time);
        if (tickerData.length === 0) continue;
        const firstValid = tickerData.find(p => p.value !== 0);
        if (!firstValid) continue;
        const baseValue = firstValid.value;
        rebasedData[ticker] = tickerData.map(p => ({ time: p.time, value: (p.value / baseValue) * 100 }));
      }

      console.log('rebased keys', Object.keys(rebasedData));
      // 4. Calculate Average and Diff Series
      const timeMap = new Map();
      Object.values(rebasedData).forEach(series => {
        series.forEach(pt => {
          if (!timeMap.has(pt.time)) timeMap.set(pt.time, { sum: 0, count: 0 });
          const entry = timeMap.get(pt.time);
          entry.sum += pt.value;
          entry.count++;
        });
      });
      const avgData = Array.from(timeMap.entries()).map(([time, { sum, count }]) => ({ time, value: sum / count }));
      const avgLookup = new Map(avgData.map(p => [p.time, p.value]));

      const diffData = {};
      for (const ticker in rebasedData) {
        diffData[ticker] = rebasedData[ticker].map(p => {
          const avgVal = avgLookup.get(p.time);
          const diff = avgVal !== undefined ? (p.value - avgVal) : 0;
          return { time: p.time, value: diff };
        });
      }

      // 5. Plot Series on Correct Panes
      for (const ticker in rebasedData) {
        // Plot normalized price on top pane (pane 0)
        const color = colors[colorIndex % colors.length];
        const priceSeries = chart.addSeries(LightweightCharts.LineSeries, { color, priceFormat: { type: 'custom', minMove: 0.1, formatter: (v)=>{ const diff=v-100; const sign=diff>0?'+':diff<0?'-':''; const decimals=Math.abs(diff)>=100?0:1; return `${sign}${Math.abs(diff).toFixed(decimals)}%`; } } });
        priceSeries.setData(rebasedData[ticker]);
        // Add zero reference line once for top pane
        if (!zeroLineTop) {
          zeroLineTop = priceSeries.createPriceLine({
            price: 100,
            color: '#888',
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.Dotted,
            axisLabelVisible: true,
            title: '0%'
          });
        }
        originalNormalizedData[ticker] = rebasedData[ticker];
        priceSeriesMap.set(ticker, priceSeries);

        if (showDiff && bottomPane) {
         // Plot diff from average on bottom pane

        const diffSeries = chart.addSeries(LightweightCharts.LineSeries, { color, lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted, priceFormat: { type: 'custom', minMove: 0.1, formatter: (v)=>{ const sign=v>0?'+':v<0?'-':''; const decimals=Math.abs(v)>=100?0:1; return `${sign}${Math.abs(v).toFixed(decimals)}%`; } } }, bottomPaneIndex);

                 diffSeries.setData(diffData[ticker]);
        // Add zero reference line once for bottom pane
        if (!zeroLineBottom) {
          zeroLineBottom = diffSeries.createPriceLine({
            price: 0,
            color: '#888',
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.Dotted,
            axisLabelVisible: true,
            title: '0%'
          });
        }
                 diffSeriesMap.set(ticker, diffSeries);
       }
        colorIndex++;
      }

      chart.timeScale().fitContent();
      // Apply logarithmic scale to main right price axis
      chart.priceScale('right').applyOptions({
        mode: LightweightCharts.PriceScaleMode.Logarithmic,
        entireTextOnly: true,
        tickMarkFormatter: (v) => {
          const diff = v - 100;
          const sign = diff > 0 ? '+' : diff < 0 ? '-' : '';
          const decimals = Math.abs(diff) >= 100 ? 0 : 1;
          return `${sign}${Math.abs(diff).toFixed(decimals)}%`;
        }
      });

      // 6. After initial draw, subscribe once to dynamic rebasing on pan/zoom
      if (!plot._rebasingAttached) {
        chart.timeScale().subscribeVisibleTimeRangeChange((visible) => {
          if (!visible || !visible.from) return;
          const fromTime = Math.round(visible.from);
          for (const [ticker, series] of priceSeriesMap.entries()) {
            const dataArr = originalNormalizedData[ticker];
            if (!dataArr || dataArr.length === 0) continue;
            // Find first point >= fromTime
            const first = dataArr.find(p => p.time >= fromTime);
            if (!first || first.value === 0) continue;
            const factor = 100 / first.value;
            const adjusted = dataArr.map(pt => ({ time: pt.time, value: pt.value * factor }));
            series.setData(adjusted);
          }
        });
        plot._rebasingAttached = true;
      }
    }

    document.getElementById('plot-btn').addEventListener('click', plot);
    // Toggle diff pane button
    document.getElementById('toggle-diff-btn').addEventListener('click', () => {
      showDiff = !showDiff;
      const btn = document.getElementById('toggle-diff-btn');
      btn.textContent = showDiff ? 'Hide Diff Pane' : 'Show Diff Pane';
      plot();
    });
    // Also plot when Enter pressed in input
    document.getElementById('tickers-input').addEventListener('keyup', (e) => {
      if (e.key === 'Enter') plot();
    });
    if (!storedTickers) plot(); // Initial plot only when nothing restored
  </script>
</body>
</html>
