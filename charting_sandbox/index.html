<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Charting Sandbox (Lightweight Charts vLatest)</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:1rem;background:#fafafa;}
    #controls{margin-bottom:1rem;}
    #chart{width:100%;height:600px;border:1px solid #ccc;background:#fff;}
    input[type=text]{width:300px;padding:4px;font-size:1rem;}
    button{padding:4px 10px;margin-left:6px;font-size:1rem;}
  </style>
  <!-- Latest Lightweight Charts build -->
  <script src="https://unpkg.com/lightweight-charts@5.0.8/dist/lightweight-charts.standalone.development.js"></script>
</head>
<body>
  <h2>Lightweight Charts Sandbox</h2>
  <div id="controls">
    <label>
      Tickers (comma-separated):
      <input id="tickers-input" type="text" value="SPY">
    </label>
    <button id="plot-btn">Plot</button>
  </div>
  <div id="chart"></div>

  <script>
    const chartContainer = document.getElementById('chart');
    // --- Chart Setup ---
    const chart = LightweightCharts.createChart(chartContainer, {
      layout: { background: { type: 'solid', color: '#ffffff' }, textColor: '#333' },
      grid: { vertLines: { color: '#eee' }, horzLines: { color: '#eee' } },
      timeScale: { secondsVisible: false, rightOffset: 10, fixLeftEdge: true },
      rightPriceScale: { visible: true, scaleMargins: { top: 0.1, bottom: 0.1 } },
      // Create a second price scale for the bottom pane
      leftPriceScale: { visible: true, scaleMargins: { top: 0.1, bottom: 0.1 } }, 
    });

    // Create two panes. The top pane (pane 0) is created by default.
    // The bottom pane for diff series
    const bottomPane = chart.addPane({ height: 120 });
    const bottomPaneIndex = bottomPane.paneIndex ? bottomPane.paneIndex() : 1; // fallback 1

      // Show an independent right-hand price scale for the bottom pane

      

    const priceSeriesMap = new Map();
    const diffSeriesMap = new Map();
    // Store original (rebased-to-100-at-start) data for each ticker to enable dynamic rebasing
    const originalNormalizedData = {};

    // Color palette for multiple tickers
    const colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0', '#546E7A', '#26a69a', '#D10CE8'];
    let colorIndex = 0;

    // --- Plotting Logic ---
    async function plot() {
      // 1. Clear existing series
      for (const series of priceSeriesMap.values()) chart.removeSeries(series);
      for (const series of diffSeriesMap.values()) chart.removeSeries(series);
      priceSeriesMap.clear();
      diffSeriesMap.clear();
      colorIndex = 0;

      // 2. Fetch Data
      const tickersRaw = document.getElementById('tickers-input').value.trim();
      if (!tickersRaw) return;
      const tickers = tickersRaw.split(/[\s,]+/).filter(Boolean).map(t => t.toUpperCase());
      const resp = await fetch(`http://localhost:5000/api/data?tickers=${tickers.join(',')}`);
      if (!resp.ok) { alert('API error'); return; }
      const rawData = await resp.json();
      console.log('raw keys', Object.keys(rawData));

      // 3. Normalize Data (Rebase to 100)
      const rebasedData = {};
      for (const ticker of tickers) {
        let tickerData = rawData[ticker]?.filter(p => p.value != null) || [];
        // Ensure data is sorted by time ascending (Lightweight Charts requirement)
        tickerData = tickerData.sort((a, b) => a.time - b.time);
        if (tickerData.length === 0) continue;
        const firstValid = tickerData.find(p => p.value !== 0);
        if (!firstValid) continue;
        const baseValue = firstValid.value;
        rebasedData[ticker] = tickerData.map(p => ({ time: p.time, value: (p.value / baseValue) * 100 }));
      }

      console.log('rebased keys', Object.keys(rebasedData));
      // 4. Calculate Average and Diff Series
      const timeMap = new Map();
      Object.values(rebasedData).forEach(series => {
        series.forEach(pt => {
          if (!timeMap.has(pt.time)) timeMap.set(pt.time, { sum: 0, count: 0 });
          const entry = timeMap.get(pt.time);
          entry.sum += pt.value;
          entry.count++;
        });
      });
      const avgData = Array.from(timeMap.entries()).map(([time, { sum, count }]) => ({ time, value: sum / count }));
      const avgLookup = new Map(avgData.map(p => [p.time, p.value]));

      const diffData = {};
      for (const ticker in rebasedData) {
        diffData[ticker] = rebasedData[ticker].map(p => {
          const avgVal = avgLookup.get(p.time);
          const diff = avgVal ? ((p.value / avgVal) - 1) * 100 : 0;
          return { time: p.time, value: diff };
        });
      }

      // 5. Plot Series on Correct Panes
      for (const ticker in rebasedData) {
        // Plot normalized price on top pane (pane 0)
        const color = colors[colorIndex % colors.length];
        const priceSeries = chart.addSeries(LightweightCharts.LineSeries, { color });
        priceSeries.setData(rebasedData[ticker]);
        originalNormalizedData[ticker] = rebasedData[ticker];
        priceSeriesMap.set(ticker, priceSeries);

        // Plot diff from average on bottom pane (pane 1)
        const diffSeries = chart.addSeries(LightweightCharts.LineSeries, { color, lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted }, bottomPaneIndex);

        diffSeries.setData(diffData[ticker]);
        diffSeriesMap.set(ticker, diffSeries);
        colorIndex++;
      }

      chart.timeScale().fitContent();

      // 6. After initial draw, subscribe once to dynamic rebasing on pan/zoom
      if (!plot._rebasingAttached) {
        chart.timeScale().subscribeVisibleTimeRangeChange((visible) => {
          if (!visible || !visible.from) return;
          const fromTime = Math.round(visible.from);
          for (const [ticker, series] of priceSeriesMap.entries()) {
            const dataArr = originalNormalizedData[ticker];
            if (!dataArr || dataArr.length === 0) continue;
            // Find first point >= fromTime
            const first = dataArr.find(p => p.time >= fromTime);
            if (!first || first.value === 0) continue;
            const factor = 100 / first.value;
            const adjusted = dataArr.map(pt => ({ time: pt.time, value: pt.value * factor }));
            series.setData(adjusted);
          }
        });
        plot._rebasingAttached = true;
      }
    }

    document.getElementById('plot-btn').addEventListener('click', plot);
    plot(); // Initial plot on load
  </script>
</body>
</html>
