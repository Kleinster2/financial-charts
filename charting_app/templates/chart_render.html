<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Chart Render</title>
    <script src="https://unpkg.com/lightweight-charts@5.0.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #ffffff; font-family: Arial, sans-serif; }
        #chart { width: 100%; height: 100vh; }
        #chart-container { width: 100%; display: flex; flex-direction: column; }
        .chart-pane { width: 100%; }
        .pane-label {
            position: absolute;
            right: 70px;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            z-index: 50;
            background: rgba(255,255,255,0.8);
            padding: 2px 8px;
            border-radius: 3px;
        }
        .title {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 32px;
            font-weight: bold;
            color: #333;
            z-index: 100;
            background: rgba(255,255,255,0.9);
            padding: 8px 14px;
            border-radius: 4px;
        }
        .watermark {
            position: absolute;
            bottom: 8px;
            right: 12px;
            font-size: 11px;
            color: rgba(0,0,0,0.3);
            z-index: 100;
        }
        .last-date {
            position: absolute;
            bottom: 10px;
            left: 16px;
            font-size: 20px;
            font-weight: 600;
            color: #333;
            z-index: 100;
        }
        .legend {
            position: absolute;
            top: 62px;
            left: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px 24px;
            z-index: 100;
            padding: 8px 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 22px;
            font-weight: 600;
            color: #333;
        }
        .legend-color {
            width: 28px;
            height: 4px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="chart"></div>
    <div id="chart-container"></div>
    <div class="title" id="title"></div>
    <div class="legend" id="legend"></div>
    <div class="last-date" id="lastDate"></div>
    <div class="watermark">Financial Charts</div>

    <script>
        // Rebase data to percentage (100 = starting point, matching dashboard style)
        function rebaseData(rawData, baseValue = null) {
            if (!rawData || rawData.length === 0) return [];
            const base = baseValue !== null ? baseValue : rawData[0].value;
            if (base === 0) return rawData;
            return rawData.map(pt => ({
                time: pt.time,
                value: (pt.value / base) * 100
            }));
        }

        // Find common start date across all series and get base values
        function getCommonBaseValues(data) {
            const tickers = Object.keys(data);
            if (tickers.length === 0) return {};

            // Find all start dates
            const startDates = tickers.map(t => data[t]?.[0]?.time).filter(Boolean);
            if (startDates.length === 0) return {};

            // Common start = latest start date (when all tickers have data)
            const commonStart = startDates.sort().pop();

            // Get base value for each ticker at common start
            const baseValues = {};
            for (const ticker of tickers) {
                const points = data[ticker];
                if (!points) continue;
                const basePoint = points.find(p => p.time >= commonStart);
                if (basePoint) {
                    baseValues[ticker] = basePoint.value;
                }
            }
            return baseValues;
        }

        // Format large numbers with K/M/B suffixes
        function formatLargeNumber(value) {
            const absValue = Math.abs(value);
            if (absValue >= 1e12) return (value / 1e12).toFixed(1) + 'T';
            if (absValue >= 1e9) return (value / 1e9).toFixed(1) + 'B';
            if (absValue >= 1e6) return (value / 1e6).toFixed(1) + 'M';
            if (absValue >= 1e3) return (value / 1e3).toFixed(1) + 'K';
            return value.toFixed(2);
        }

        // Create a single chart pane with series
        function createChartPane(container, seriesData, config, paneHeight, colorMap, isLastPane) {
            const { width, showLastValue, normalize, isFundamentals, forecastStart, labels } = config;

            const chart = LightweightCharts.createChart(container, {
                width: width || 1200,
                height: paneHeight,
                layout: {
                    background: { type: 'solid', color: '#ffffff' },
                    textColor: '#333',
                    fontSize: 18
                },
                grid: {
                    vertLines: { color: '#eee' },
                    horzLines: { color: '#eee' }
                },
                timeScale: {
                    visible: isLastPane,  // Only show time scale on last pane
                    secondsVisible: false,
                    rightOffset: 5,
                    borderColor: '#ccc',
                    fixLeftEdge: true,
                    fixRightEdge: true,
                    uniformDistribution: true
                },
                rightPriceScale: {
                    visible: true,
                    borderColor: '#ccc',
                    scaleMargins: { top: 0.1, bottom: 0.1 },
                    mode: isFundamentals ? 0 : 1,  // Arithmetic for fundamentals (can go negative), log for prices
                    minimumWidth: isFundamentals ? 110 : 0
                },
                leftPriceScale: {
                    visible: false
                },
                crosshair: {
                    horzLine: { visible: false },
                    vertLine: { visible: false }
                }
            });

            // Price formatter for fundamentals
            const priceFormat = {
                type: 'custom',
                minMove: 1,
                formatter: formatLargeNumber
            };

            // Add series
            for (const [seriesName, points] of Object.entries(seriesData)) {
                const color = colorMap[seriesName] || '#2962FF';
                const chartData = points.map(p => ({ time: p.time, value: p.value }));

                if (forecastStart) {
                    const historicalData = chartData.filter(p => p.time < forecastStart);
                    const forecastData = chartData.filter(p => p.time >= forecastStart);

                    if (historicalData.length > 0 && forecastData.length > 0) {
                        forecastData.unshift(historicalData[historicalData.length - 1]);
                    }

                    if (historicalData.length > 0) {
                        const historicalSeries = chart.addSeries(LightweightCharts.LineSeries, {
                            color: color,
                            lineWidth: 2,
                            lastValueVisible: forecastData.length > 0,
                            priceLineVisible: false,
                            crosshairMarkerVisible: false,
                            priceFormat: priceFormat
                        });
                        historicalSeries.setData(historicalData);

                        if (forecastData.length > 0) {
                            const lastPoint = historicalData[historicalData.length - 1];
                            LightweightCharts.createSeriesMarkers(historicalSeries, [{
                                time: lastPoint.time,
                                position: 'inBar',
                                color: color,
                                shape: 'circle',
                                size: 2
                            }]);
                        }
                    }

                    if (forecastData.length > 0) {
                        const forecastSeries = chart.addSeries(LightweightCharts.LineSeries, {
                            color: color,
                            lineWidth: 2,
                            lineStyle: 1,
                            lastValueVisible: false,
                            priceLineVisible: false,
                            crosshairMarkerVisible: false,
                            priceFormat: priceFormat
                        });
                        forecastSeries.setData(forecastData);
                    }
                } else {
                    const series = chart.addSeries(LightweightCharts.LineSeries, {
                        color: color,
                        lineWidth: 2,
                        lastValueVisible: showLastValue || false,
                        priceLineVisible: false,
                        crosshairMarkerVisible: false,
                        priceFormat: priceFormat
                    });
                    series.setData(chartData);
                }
            }

            return chart;
        }

        // Render multi-pane chart for fundamentals using v5 native panes (single chart, shared time axis)
        function renderMultiPaneChart(config) {
            const { data, title, width, height, showLastDate, paneGroups, forecastStart, isFundamentals } = config;

            // Hide single chart container, use multi-pane container
            document.getElementById('chart').style.display = 'none';
            const container = document.getElementById('chart-container');
            container.style.height = height + 'px';

            // Hide title for fundamentals
            document.getElementById('title').style.display = 'none';
            document.getElementById('lastDate').style.display = 'none';

            // Move legend to top
            const legendEl = document.getElementById('legend');
            legendEl.style.top = '15px';

            // Color palette
            const colors = [
                '#2962FF', '#E91E63', '#4CAF50', '#FF9800',
                '#9C27B0', '#00BCD4', '#795548', '#607D8B'
            ];

            // Assign colors to series
            const colorMap = {};
            let colorIndex = 0;
            for (const seriesName of Object.keys(data)) {
                colorMap[seriesName] = colors[colorIndex % colors.length];
                colorIndex++;
            }

            // Build legend
            for (const [seriesName, color] of Object.entries(colorMap)) {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `<div class="legend-color" style="background:${color}"></div><span>${seriesName}</span>`;
                legendEl.appendChild(item);
            }

            // Add date to legend
            if (showLastDate !== false) {
                let maxDate = null;
                for (const points of Object.values(data)) {
                    for (const pt of points) {
                        if (forecastStart && pt.time >= forecastStart) continue;
                        if (!maxDate || pt.time > maxDate) maxDate = pt.time;
                    }
                }
                if (maxDate) {
                    const d = new Date(maxDate + 'T00:00:00');
                    const dateItem = document.createElement('div');
                    dateItem.className = 'legend-item';
                    dateItem.style.color = '#666';
                    const prefix = forecastStart ? 'Actual: ' : '';
                    dateItem.innerHTML = `<span>${prefix}${d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</span>`;
                    legendEl.appendChild(dateItem);
                }
            }

            // Create chart container div with legend offset
            const chartWrapper = document.createElement('div');
            chartWrapper.style.position = 'relative';
            chartWrapper.style.marginTop = '70px';
            const chartDiv = document.createElement('div');
            chartDiv.id = 'multi-pane-chart';
            chartWrapper.appendChild(chartDiv);
            container.appendChild(chartWrapper);

            const legendHeight = 70;
            const chartHeight = height - legendHeight;

            // Create a single chart instance — all panes share one time axis
            const chart = LightweightCharts.createChart(chartDiv, {
                width: width || 1200,
                height: chartHeight,
                layout: {
                    background: { type: 'solid', color: '#ffffff' },
                    textColor: '#333',
                    fontSize: 18
                },
                grid: {
                    vertLines: { color: '#eee' },
                    horzLines: { color: '#eee' }
                },
                timeScale: {
                    secondsVisible: false,
                    rightOffset: 5,
                    borderColor: '#ccc',
                    fixLeftEdge: true,
                    fixRightEdge: true
                },
                rightPriceScale: {
                    visible: true,
                    borderColor: '#ccc',
                    scaleMargins: { top: 0.1, bottom: 0.1 },
                    mode: 0
                },
                leftPriceScale: {
                    visible: false
                },
                crosshair: {
                    horzLine: { visible: false },
                    vertLine: { visible: false }
                }
            });

            // Price formatter for fundamentals
            const priceFormat = {
                type: 'custom',
                minMove: 1,
                formatter: formatLargeNumber
            };

            // Add series to panes — paneIndex 0 for first metric, 1 for second, etc.
            const paneNames = Object.keys(paneGroups);
            paneNames.forEach((paneName, paneIndex) => {
                const seriesKeys = paneGroups[paneName];

                for (const key of seriesKeys) {
                    if (!data[key]) continue;

                    const color = colorMap[key] || '#2962FF';
                    const chartData = data[key].map(p => ({ time: p.time, value: p.value }));

                    if (forecastStart) {
                        const historicalData = chartData.filter(p => p.time < forecastStart);
                        const forecastData = chartData.filter(p => p.time >= forecastStart);

                        if (historicalData.length > 0 && forecastData.length > 0) {
                            forecastData.unshift(historicalData[historicalData.length - 1]);
                        }

                        if (historicalData.length > 0) {
                            const historicalSeries = chart.addSeries(LightweightCharts.LineSeries, {
                                color: color,
                                lineWidth: 2,
                                lastValueVisible: forecastData.length > 0,
                                priceLineVisible: false,
                                crosshairMarkerVisible: false,
                                priceFormat: priceFormat
                            }, paneIndex);
                            historicalSeries.setData(historicalData);

                            if (forecastData.length > 0) {
                                const lastPoint = historicalData[historicalData.length - 1];
                                LightweightCharts.createSeriesMarkers(historicalSeries, [{
                                    time: lastPoint.time,
                                    position: 'inBar',
                                    color: color,
                                    shape: 'circle',
                                    size: 2
                                }]);
                            }
                        }

                        if (forecastData.length > 0) {
                            const forecastSeries = chart.addSeries(LightweightCharts.LineSeries, {
                                color: color,
                                lineWidth: 2,
                                lineStyle: 1,
                                lastValueVisible: false,
                                priceLineVisible: false,
                                crosshairMarkerVisible: false,
                                priceFormat: priceFormat
                            }, paneIndex);
                            forecastSeries.setData(forecastData);
                        }
                    } else {
                        const series = chart.addSeries(LightweightCharts.LineSeries, {
                            color: color,
                            lineWidth: 2,
                            lastValueVisible: false,
                            priceLineVisible: false,
                            crosshairMarkerVisible: false,
                            priceFormat: priceFormat
                        }, paneIndex);
                        series.setData(chartData);
                    }
                }
            });

            // Add pane labels as overlays positioned within the chart wrapper
            const paneCount = paneNames.length;
            const paneUnitHeight = chartHeight / paneCount;
            paneNames.forEach((paneName, index) => {
                const label = document.createElement('div');
                label.className = 'pane-label';
                label.style.top = (index * paneUnitHeight + 16) + 'px';
                label.textContent = paneName;
                chartWrapper.appendChild(label);
            });

            // Fit content and signal ready
            setTimeout(() => {
                chart.timeScale().fitContent();
                window.chartReady = true;
            }, 150);
        }

        // Chart configuration will be injected via window.CHART_CONFIG
        function renderChart(config) {
            const { data, title, width, height, showTitle, showLastDate, showLastValue, normalize, isFundamentals, forecastStart, labels, separatePanes, paneGroups, overlay } = config;

            // Use multi-pane rendering for fundamentals with multiple metrics
            if (separatePanes && paneGroups && Object.keys(paneGroups).length > 1) {
                return renderMultiPaneChart(config);
            }

            // Find last date across all series (will add to legend later)
            // For fundamentals with forecast, find last ACTUAL date (before forecastStart)
            let lastDateFormatted = null;
            if (showLastDate !== false) {
                let maxDate = null;
                for (const points of Object.values(data)) {
                    if (points && points.length > 0) {
                        for (const pt of points) {
                            // For fundamentals with forecast, only consider dates before forecastStart
                            if (isFundamentals && forecastStart && pt.time >= forecastStart) continue;
                            if (!maxDate || pt.time > maxDate) {
                                maxDate = pt.time;
                            }
                        }
                    }
                }
                if (maxDate) {
                    const d = new Date(maxDate + 'T00:00:00');
                    lastDateFormatted = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                }
            }
            // Hide standalone date element (now in legend)
            document.getElementById('lastDate').style.display = 'none';

            // Set title (hide if legend is sufficient: normalized multi-ticker or fundamentals)
            const titleEl = document.getElementById('title');
            const tickers = Object.keys(data);
            const hideTitle = (normalize && tickers.length > 1) || isFundamentals;
            if (showTitle && title && !hideTitle) {
                titleEl.textContent = title;
            } else {
                titleEl.style.display = 'none';
            }

            // Create chart
            const chartContainer = document.getElementById('chart');
            const chart = LightweightCharts.createChart(chartContainer, {
                width: width || 1200,
                height: height || 600,
                layout: {
                    background: { type: 'solid', color: '#ffffff' },
                    textColor: '#333',
                    fontSize: 20
                },
                grid: {
                    vertLines: { color: '#eee' },
                    horzLines: { color: '#eee' }
                },
                timeScale: {
                    secondsVisible: false,
                    rightOffset: 5,
                    borderColor: '#ccc'
                },
                rightPriceScale: {
                    visible: true,
                    borderColor: '#ccc',
                    scaleMargins: { top: 0.1, bottom: 0.1 },
                    mode: isFundamentals ? 0 : 1  // Arithmetic for fundamentals (can go negative), log for prices
                },
                leftPriceScale: {
                    visible: !!overlay,
                    borderColor: '#ccc',
                    scaleMargins: { top: 0.1, bottom: 0.3 },
                    mode: 0  // Normal mode for percentages
                },
                crosshair: {
                    horzLine: { visible: false },
                    vertLine: { visible: false }
                }
            });

            // Color palette matching dashboard
            const colors = [
                '#2962FF', '#E91E63', '#4CAF50', '#FF9800',
                '#9C27B0', '#00BCD4', '#795548', '#607D8B'
            ];

            // Build legend (move up if no title)
            const legendEl = document.getElementById('legend');
            if (hideTitle) {
                legendEl.style.top = '15px';
            }

            // Get common base values for normalized charts
            const baseValues = normalize ? getCommonBaseValues(data) : {};

            // Add series for each ticker
            let colorIndex = 0;
            for (const [ticker, points] of Object.entries(data)) {
                const color = colors[colorIndex % colors.length];

                // Add legend item (use custom label if provided)
                const item = document.createElement('div');
                item.className = 'legend-item';
                const displayLabel = (labels && labels[ticker]) ? labels[ticker] : ticker;
                item.innerHTML = `<div class="legend-color" style="background:${color}"></div><span>${displayLabel}</span>`;
                legendEl.appendChild(item);

                // Price formatter based on mode
                let priceFormat;
                if (normalize) {
                    priceFormat = {
                        type: 'custom',
                        minMove: 0.1,
                        formatter: (v) => {
                            const diff = v - 100;
                            const sign = diff > 0 ? '+' : diff < 0 ? '-' : '';
                            const dec = Math.abs(diff) >= 100 ? 0 : Math.abs(diff) >= 10 ? 1 : 2;
                            return `${sign}${Math.abs(diff).toFixed(dec)}%`;
                        }
                    };
                } else if (isFundamentals) {
                    priceFormat = {
                        type: 'custom',
                        minMove: 1,
                        formatter: formatLargeNumber
                    };
                } else {
                    priceFormat = { type: 'price', precision: 2, minMove: 0.01 };
                }

                // Convert data format, apply rebasing if normalize=true (using common base)
                const chartData = normalize ? rebaseData(points, baseValues[ticker]) : points.map(p => ({
                    time: p.time,
                    value: p.value
                }));

                // Split into historical and forecast if forecastStart is provided
                if (forecastStart) {
                    const historicalData = chartData.filter(p => p.time < forecastStart);
                    const forecastData = chartData.filter(p => p.time >= forecastStart);

                    // Add last historical point to forecast for continuity
                    if (historicalData.length > 0 && forecastData.length > 0) {
                        forecastData.unshift(historicalData[historicalData.length - 1]);
                    }

                    // Historical series (solid line)
                    if (historicalData.length > 0) {
                        const showLastValueForSeries = showLastValue || (forecastData.length > 0 && isFundamentals);
                        const historicalSeries = chart.addSeries(LightweightCharts.LineSeries, {
                            color: color,
                            lineWidth: 2,
                            lastValueVisible: showLastValueForSeries,
                            priceLineVisible: false,
                            crosshairMarkerVisible: false,
                            priceFormat: priceFormat
                        });
                        historicalSeries.setData(historicalData);

                        // Add dot at forecast transition point
                        if (forecastData.length > 0) {
                            const lastPoint = historicalData[historicalData.length - 1];
                            LightweightCharts.createSeriesMarkers(historicalSeries, [{
                                time: lastPoint.time,
                                position: 'inBar',
                                color: color,
                                shape: 'circle',
                                size: 2
                            }]);
                        }
                    }

                    // Forecast series (dotted line)
                    if (forecastData.length > 0) {
                        const forecastSeries = chart.addSeries(LightweightCharts.LineSeries, {
                            color: color,
                            lineWidth: 2,
                            lineStyle: 1,  // Dotted
                            lastValueVisible: false,
                            priceLineVisible: false,
                            crosshairMarkerVisible: false,
                            priceFormat: priceFormat
                        });
                        forecastSeries.setData(forecastData);
                    }
                } else {
                    // No forecast split - single solid line
                    const series = chart.addSeries(LightweightCharts.LineSeries, {
                        color: color,
                        lineWidth: 2,
                        lastValueVisible: showLastValue || false,
                        priceLineVisible: false,
                        crosshairMarkerVisible: false,
                        priceFormat: priceFormat
                    });
                    series.setData(chartData);
                }

                colorIndex++;
            }

            // Render overlay series (e.g., short interest)
            if (overlay && overlay.data) {
                // Muted overlay colors — one per ticker, tinted gray
                const overlayColors = [
                    'rgba(120, 120, 160, 0.6)',
                    'rgba(160, 120, 120, 0.6)',
                    'rgba(120, 160, 120, 0.6)',
                    'rgba(160, 160, 120, 0.6)'
                ];
                const overlayFills = [
                    ['rgba(120, 120, 160, 0.15)', 'rgba(120, 120, 160, 0.02)'],
                    ['rgba(160, 120, 120, 0.15)', 'rgba(160, 120, 120, 0.02)'],
                    ['rgba(120, 160, 120, 0.15)', 'rgba(120, 160, 120, 0.02)'],
                    ['rgba(160, 160, 120, 0.15)', 'rgba(160, 160, 120, 0.02)']
                ];

                let overlayIdx = 0;
                for (const [seriesName, points] of Object.entries(overlay.data)) {
                    const oColor = overlayColors[overlayIdx % overlayColors.length];
                    const [topColor, bottomColor] = overlayFills[overlayIdx % overlayFills.length];

                    const areaSeries = chart.addSeries(LightweightCharts.AreaSeries, {
                        priceScaleId: 'left',
                        lineColor: oColor,
                        topColor: topColor,
                        bottomColor: bottomColor,
                        lineWidth: 1,
                        lastValueVisible: false,
                        priceLineVisible: false,
                        crosshairMarkerVisible: false,
                        priceFormat: {
                            type: 'custom',
                            minMove: 0.1,
                            formatter: (v) => v.toFixed(1) + '%'
                        }
                    });
                    areaSeries.setData(points);

                    // Add overlay legend entry with lighter styling
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.style.opacity = '0.7';
                    item.innerHTML = `<div class="legend-color" style="background:${oColor}; height: 8px;"></div><span>${seriesName}</span>`;
                    legendEl.appendChild(item);

                    overlayIdx++;
                }
            }

            // Add date to legend after tickers
            if (lastDateFormatted) {
                const dateItem = document.createElement('div');
                dateItem.className = 'legend-item';
                dateItem.style.color = '#666';
                // For fundamentals with forecast, show "Actual: date"
                const prefix = (isFundamentals && forecastStart) ? 'Actual: ' : '';
                dateItem.innerHTML = `<span>${prefix}${lastDateFormatted}</span>`;
                legendEl.appendChild(dateItem);
            }

            // Delay fitContent to ensure data is rendered
            setTimeout(() => {
                chart.timeScale().fitContent();
                // Signal ready for screenshot
                window.chartReady = true;
            }, 100);
        }

        // Wait for config to be injected
        if (window.CHART_CONFIG) {
            renderChart(window.CHART_CONFIG);
        }
    </script>
</body>
</html>
