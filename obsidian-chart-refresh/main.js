var R=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var D=Object.getOwnPropertyNames;var U=Object.prototype.hasOwnProperty;var V=(r,t)=>{for(var e in t)R(r,e,{get:t[e],enumerable:!0})},X=(r,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of D(t))!U.call(r,a)&&a!==e&&R(r,a,{get:()=>t[a],enumerable:!(s=x(t,a))||s.enumerable});return r};var F=r=>X(R({},"__esModule",{value:!0}),r);var Y={};V(Y,{default:()=>w});module.exports=F(Y);var u=require("obsidian");var B={VIX:"^VIX",VIX1D:"^VIX1D",VIX3M:"^VIX3M",VIX6M:"^VIX6M",VIX9D:"^VIX9D",VVIX:"^VVIX",GSPC:"^GSPC",DJI:"^DJI",IXIC:"^IXIC",TNX:"^TNX"};function y(r){var t;return(t=B[r])!=null?t:r}function A(r){let t=r.replace(/\.png$/i,"");if(t.includes("-fundamentals")||t.includes("fundamentals"))return{type:"skip",reason:"fundamentals chart"};if(t.includes("-vs-"))return T(t);if(t.includes("-price-chart"))return N(t);let e=z(t);if(e)return e;let s=L(t);return s||{type:"unknown",filename:r}}function T(r){let t=r.match(/-(\d{4})$/),e=t?t[1]:null,s=e?r.replace(/-\d{4}$/,""):r,a=s.endsWith("-fx");a&&(s=s.replace(/-fx$/,""));let h=s.split("-vs-").map(c=>{let i=c.replace(/-price-chart$/,"").replace(/_/g,".").toUpperCase();return a&&(i=i+"=X"),y(i)});if(h.length<2)return{type:"unknown",filename:r};for(let c of h)if(!/^\^?[A-Z0-9.\-]{1,15}(=X)?$/.test(c))return{type:"unknown",filename:r};let o={tickers:h,normalize:!0,sortByLast:!0,primary:h[0]};return e&&(o.start=`${e}-01-01`),{type:"parsed",params:o}}function N(r){let t=r.match(/-(\d{4})$/),e=t?t[1]:null,s=r;if(e&&(s=s.replace(/-\d{4}$/,"")),s=y(s.replace(/-price-chart$/,"").replace(/_/g,".").toUpperCase()),!/^\^?[A-Z0-9.]{1,15}$/.test(s))return{type:"unknown",filename:r};let a={tickers:[s],normalize:!1};return e&&(a.start=`${e}-01-01`),{type:"parsed",params:a}}function z(r){if(!r.endsWith("-ytd"))return null;let t=r.replace(/-ytd$/,""),e=new Date().getFullYear().toString();if(t.includes("-vs-"))return T(t+`-${e}`);let s=y(t.replace(/_/g,".").toUpperCase());return/^\^?[A-Z0-9.]{1,15}$/.test(s)?{type:"parsed",params:{tickers:[s],normalize:!1,start:`${e}-01-01`}}:null}function L(r){let t=r.match(/^(.+)-(\d+)(d|y)$/i);if(!t)return null;let[,e,s,a]=t,l=parseInt(s,10),h=y(e.replace(/_/g,".").toUpperCase());if(!/^\^?[A-Z0-9.]{1,15}$/.test(h))return null;let o=new Date,c;a.toLowerCase()==="y"?c=l*365:c=l;let n=new Date(o.getTime()-c*24*60*60*1e3).toISOString().split("T")[0];return{type:"parsed",params:{tickers:[h],normalize:!1,start:n}}}function S(r){let t=new Map,e=r.match(/^---\n([\s\S]*?)\n---/);if(!e)return t;let a=e[1].match(/charts:\n([\s\S]*?)(?=\n[^\s]|$)/);if(!a)return t;let l=a[1],h=/^\s{2}([^\s:]+\.png):\n((?:\s{4}[^\n]+\n?)*)/gm,o;for(;(o=h.exec(l))!==null;){let c=o[1],i=o[2],n={},p=i.match(/tickers:\s*([^\n]+)/);p&&(n.tickers=p[1].trim());let g=i.match(/normalize:\s*(true|false)/);g&&(n.normalize=g[1]==="true");let m=i.match(/start:\s*([^\n]+)/);m&&(n.start=m[1].trim());let P=i.match(/skip:\s*(true|false)/);P&&(n.skip=P[1]==="true");let I=i.match(/primary:\s*([^\n]+)/);I&&(n.primary=I[1].trim()),t.set(c,n)}return t}function v(r){var e,s;if(r.skip||!r.tickers)return null;let t=r.tickers.split(",").map(a=>a.trim());return{tickers:t,normalize:(e=r.normalize)!=null?e:!1,start:r.start,primary:(s=r.primary)!=null?s:t[0]}}function C(r,t){let e=new URL("/api/chart/lw",r);return e.searchParams.set("tickers",t.tickers.join(",")),t.normalize&&e.searchParams.set("normalize","true"),t.start&&e.searchParams.set("start",t.start),t.sortByLast&&e.searchParams.set("sort_by_last","true"),t.primary&&e.searchParams.set("primary",t.primary),e.toString()}var k=require("obsidian");async function b(r){try{let t=await(0,k.requestUrl)({url:r,method:"GET"});return t.status!==200?(console.log(`Chart API returned status ${t.status}`),null):t.arrayBuffer}catch(t){return console.log(`Chart fetch failed (API not running?): ${t}`),null}}async function $(r,t,e,s){try{let a=`${s}/${t}`;return await r.adapter.writeBinary(a,new Uint8Array(e)),!0}catch(a){return console.error(`Failed to write chart image: ${a}`),!1}}async function M(r){try{return(await(0,k.requestUrl)({url:r,method:"GET",throw:!1})).status<400}catch(t){return!1}}var f=require("obsidian"),E={apiBaseUrl:"http://localhost:5000",attachmentsFolder:"investing/attachments",autoRefresh:!0,cacheTtlMinutes:5},d=class extends f.PluginSettingTab{constructor(e,s){super(e,s);this.plugin=s}display(){let{containerEl:e}=this;e.empty(),e.createEl("h2",{text:"Chart Refresh Settings"}),new f.Setting(e).setName("Auto-refresh on note open").setDesc("Automatically refresh price charts when a note is opened").addToggle(s=>s.setValue(this.plugin.settings.autoRefresh).onChange(async a=>{this.plugin.settings.autoRefresh=a,await this.plugin.saveSettings()})),new f.Setting(e).setName("API base URL").setDesc("Base URL for the chart API (default: http://localhost:5000)").addText(s=>s.setPlaceholder("http://localhost:5000").setValue(this.plugin.settings.apiBaseUrl).onChange(async a=>{this.plugin.settings.apiBaseUrl=a,await this.plugin.saveSettings()})),new f.Setting(e).setName("Attachments folder").setDesc("Folder path where chart images are stored").addText(s=>s.setPlaceholder("investing/attachments").setValue(this.plugin.settings.attachmentsFolder).onChange(async a=>{this.plugin.settings.attachmentsFolder=a,await this.plugin.saveSettings()})),new f.Setting(e).setName("Cache TTL (minutes)").setDesc("Skip refresh if image was updated less than this many minutes ago").addText(s=>s.setPlaceholder("5").setValue(String(this.plugin.settings.cacheTtlMinutes)).onChange(async a=>{let l=parseInt(a,10);!isNaN(l)&&l>=0&&(this.plugin.settings.cacheTtlMinutes=l,await this.plugin.saveSettings())}))}};var _=/!\[\[([^\]]+\.png)\]\]/gi,G=["chart-registry.md","investing/chart-registry.md"],w=class extends u.Plugin{constructor(){super(...arguments);this.lastRefreshTimes=new Map;this.apiAvailable=null;this.registry=new Map;this.isRefreshing=!1}async onload(){await this.loadSettings(),await this.loadRegistry(),this.addSettingTab(new d(this.app,this)),this.registerEvent(this.app.workspace.on("file-open",async e=>{e&&this.settings.autoRefresh&&!this.isRefreshing&&await this.refreshChartsInNote(e)})),this.addCommand({id:"refresh-charts-current-note",name:"Refresh charts in current note",callback:async()=>{let e=this.app.workspace.getActiveFile();e&&await this.refreshChartsInNote(e,!0)}}),this.addCommand({id:"reload-chart-registry",name:"Reload chart registry",callback:async()=>{await this.loadRegistry(),new u.Notice(`Loaded ${this.registry.size} chart(s) from registry`)}}),this.app.workspace.onLayoutReady(()=>{if(this.settings.autoRefresh){let e=this.app.workspace.getActiveFile();e&&this.refreshChartsInNote(e)}}),console.log("Chart Refresh plugin loaded")}async loadRegistry(){for(let e of G)try{let s=this.app.vault.getAbstractFileByPath(e);if(s&&s instanceof u.TFile){let a=await this.app.vault.read(s);this.registry=S(a),console.log(`Loaded ${this.registry.size} chart(s) from registry (${e})`);return}}catch(s){console.log(`Could not load chart registry from ${e}: ${s}`)}}onunload(){console.log("Chart Refresh plugin unloaded")}async loadSettings(){this.settings=Object.assign({},E,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}async refreshChartsInNote(e,s=!1){try{let l=[...(await this.app.vault.read(e)).matchAll(_)];if(l.length===0){s&&new u.Notice("No chart embeds found in this note");return}let h=[...new Set(l.map(i=>i[1]))],o=[];for(let i of h){let n=A(i);if(n.type!=="skip"){if(n.type==="unknown"){let p=this.registry.get(i);if(p){if(p.skip)continue;let g=v(p);if(g){if(!s&&!this.shouldRefresh(i))continue;let m=C(this.settings.apiBaseUrl,g);o.push({filename:i,apiUrl:m})}}continue}if(n.type==="parsed"){if(!s&&!this.shouldRefresh(i))continue;let p=C(this.settings.apiBaseUrl,n.params);o.push({filename:i,apiUrl:p})}}}if(o.length===0){s&&new u.Notice("No charts to refresh");return}if((this.apiAvailable===null||this.apiAvailable===!1)&&(this.apiAvailable=await M(this.settings.apiBaseUrl)),!this.apiAvailable){s&&new u.Notice("Chart API not available");return}let c=0;for(let{filename:i,apiUrl:n}of o){let p=await b(n);p&&await $(this.app.vault,i,p,this.settings.attachmentsFolder)&&(this.lastRefreshTimes.set(i,Date.now()),c++)}if(c>0){await new Promise(n=>setTimeout(n,200));let i=this.app.workspace.getLeaf(!1);i&&(this.isRefreshing=!0,await i.openFile(e,{active:!0}),this.isRefreshing=!1)}s&&new u.Notice(`Refreshed ${c} chart(s)`)}catch(a){new u.Notice(`Chart Refresh error: ${a}`),console.error("Chart Refresh error:",a)}}shouldRefresh(e){let s=this.lastRefreshTimes.get(e);if(!s)return!0;let a=this.settings.cacheTtlMinutes*60*1e3;return Date.now()-s>a}};
